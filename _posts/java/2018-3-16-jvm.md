---
layout:     post
title:      "JVM 基础和内存泄露分析"  
subtitle:   "如何分析内存泄露问题"
author:     Sun Jianjiao
header-img: "img/bg/default-bg.jpg"
catalog: true
tags:
    - java

---

# Java 代码时如何运行的

一旦一个程序被转换成 Java 字节码，那么它便可以在不同平台上的虚拟机实现里运行。这也就是我们经常说的“一次编写, 导出运行", 虚拟机的另一个好处是有一个托管环境，能够代替我们处理一些代码中冗长而容易出错的部分。其中最为广为人知的当属自动内存管理与垃圾回收。

执行Java代码首先需要将class文件加载到Java虚拟机中。加载后的Java类会被存放于方法区(Method Area) 中。实际运行时，虚拟机会执行方法区的代码。

在运行过程中，每当调用进入一个Java方法，Java虚拟机会在当前线程的Java方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且Java虚拟机不要求栈帧在内存空间里连续分布。

当退出当前执行的方法时，不管是正常返回还是一场反回，Java虚拟机均会弹出当前线程的栈帧，并将之舍弃。

从硬件角度看，Java自己吗无法直接执行。因此，Java虚拟机需要将字节码翻译成机器码。

Java字节码无法直接执行。因此Java虚拟机需要将字节码翻译成机器码。在HotSpot里面，上述翻译有两种形式，第一种是解释执行，即逐条将字节码翻译成机器码。第二种是即时编译(JIT), 即将一个方法中包含的所有自己码编译成机器码后再执行。

![memory](/img/post/java/jvm/JIT.png)

前者的优势在于无需等待编译，而后者的优势在于实际运行速度更快。HotSpot 默认采用混合模式，综合了解释执行和即时编译的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。

# 垃圾回收

## 如何判别一个对象是否死亡

引用记数法，每个对象添加一个引用计数器，用来统计指向该对象的引用计数。但是引用计数法无法解决循环引用问题。
可达性分析法，将一系列GC Roots作为初时的存货对象合集，从合计出发，探索所有能被改集合引用到的对象，并将其加入到集合中，我们成为标记(mark), 最终，未被探索到的对象是死亡的，可以回收的。
GC Roots主要有如下几种：

- Java方法栈中的局部变量；
- 已加载类的静态变量；
- JNI handles;
- 已启动且未停止的Java线程；

Stop-the-world, 多线程情况下，为了避免漏报或者误报，停止其他非来及回收线程的工作，知道垃圾回收完成。

回收死亡对象的内存共有三种方式，分别为：会造成内存碎片的清除，性能开销较大的压缩、以及堆使用效率较低的复制。

# JVM基础
Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。

## 运行时数据区域
![memory](/img/post/java/jvm/memory.png)

- 程序计数器是一块很小的内存空间，可以看作是当前线程所执行的字节码行号指示器。为了线程切换后能恢复到正确的执行位置，PC是线程私有的。

- Java虚拟机栈，线程私有，虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（栈帧表示程序的函数调用记录，栈上保持了N个栈帧的实体，栈帧不仅保存诸如：函数入参、出参、返回地址和上一个栈帧的栈底指针等信息，还保存了函数内部的自动变量）。每一个方法从调用直至执行完成就对应着一个栈帧在虚拟机战中的入栈到出栈的过程。

- 本地方法栈：为虚拟机使用到的Native方法服务。hotspot直接将本地方法和虚拟机栈合二为一。

- Java堆：存放对象实例和数组。
- 方法区：存储已被虚拟机加载的类信息，常量，静态变量，及时编译器编译后的代码等数据。 还有运行时常量池——存放编译器生成的各种字面量和符号引用。

## 内存模型

happen-before关系: 操作X happens-before 操作Y，那么X的结果对于Y可见。
通过内存屏障禁止重排序。


## 内存分配
![memory](/img/post/java/jvm/memory-heap.png)

大部分的 Java 对象只存活一小段时间，而存活下来的小部分 Java 对象则会存活很长一段时间。

- 新生代（Young Generation）：大多数对象在新生代中被创建，其中很多对象的生命周期很短。每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收。

标记-复制算法：
当Eden区满时，进行一次MinorGC, 还存活的对象将被复制到S0区。当S0区满时，此区的存活且不满足“晋升”条件的对象将被复制到S1区。对象每经历一次Minor GC，年龄加1，达到“晋升年龄阈值”后，被放到老年代，这个过程也称为“晋升”。显然，“晋升年龄阈值”的大小直接影响着对象在新生代中的停留时间，在Serial和ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15。

- 老年代（Old Generation）：在新生代中经历了MaxTenuringThreshold次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高。老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法。整堆包括新生代和老年代的垃圾回收称为Full GC（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。大对象会直接放到老年代。通过动态判定，同龄对象占用空间的和大于survivor的一半时，进入老年代。

# Java 虚拟机的监控及诊断工具

## 命令行参数

- jps, 打印正在运行的进程的相关信息。 -l打印模块名及包名；-v 打印个java虚拟机的参数；-m打印传递给主类的参数。
- jstat, 打印目标java进程的性能数据，并且可以设置每隔多长时间打印一次。可以用来判断是否出现内存泄漏，取OU列，获得多组OU的最小值，如果这些值呈上涨趋势，说明该java程序老年代内存在不断上涨，可能存在内存泄漏。

- jmap, 分析堆中的对象。
- jinfo, 查看java进程的参数。
- jstack， 打印目标java继承中各个线程的栈轨迹，以及这些线程所持有的锁。其中一个应用场景就是死锁检测,不仅会打印线程的栈轨迹，线程状态，持有的锁，以及正在请求的锁，还会分析出具体的死锁。
- jcmd, 可以代替除了jstat外的所有功能。
 

# 案例
## 感觉发生了内存泄漏

隔一段时间通过docker stat查看容器状态，发现export-distro的内存不断增长。 

1. 启动了telegraph长时间观察内存情况。
2. 开启GC日志。

# 术语说明

- [1]栈帧：  。

