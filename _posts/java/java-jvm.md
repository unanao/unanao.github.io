# JVM基础
Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。

## jvm 内存模型
![memory](/img/post/java/jvm/memory.png)

- 程序计数器是一块很小的内存空间，可以看作是当前线程所执行的字节码行号指示器。为了线程切换后能恢复到正确的执行位置，PC是线程私有的。

- Java虚拟机栈，线程私有，虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（栈帧表示程序的函数调用记录，栈上保持了N个栈帧的实体，栈帧不仅保存诸如：函数入参、出参、返回地址和上一个栈帧的栈底指针等信息，还保存了函数内部的自动变量）。每一个方法从调用直至执行完成就对应着一个栈帧在虚拟机战中的入栈到出栈的过程。

- 本地方法栈：为虚拟机使用到的Native方法服务。hotspot直接将本地方法和虚拟机栈合二为一。

- Java堆：存放对象实例和数组。
- 方法区：存储已被虚拟机加载的类信息，常量，静态变量，及时编译器编译后的代码等数据。 还有运行时常量池——存放编译器生成的各种字面量和符号引用。

## 内存分配
![memory](/img/post/java/jvm/memory-heap.png)

- 新生代（Young Generation）：大多数对象在新生代中被创建，其中很多对象的生命周期很短。每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收。

当Eden区满时，进行一次MinorGC, 还存活的对象将被复制到S0区。当S0区满时，此区的存活且不满足“晋升”条件的对象将被复制到S1区。对象每经历一次Minor GC，年龄加1，达到“晋升年龄阈值”后，被放到老年代，这个过程也称为“晋升”。显然，“晋升年龄阈值”的大小直接影响着对象在新生代中的停留时间，在Serial和ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15。

- 老年代（Old Generation）：在新生代中经历了MaxTenuringThreshold次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高。老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法。整堆包括新生代和老年代的垃圾回收称为Full GC（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。大对象会直接放到老年代。通过动态判定，同龄对象占用空间的和大于survivor的一半时，进入老年代。

# 案例
## 感觉发生了内存泄漏

隔一段时间通过docker stat查看容器状态，发现export-distro的内存不断增长。 

1. 启动了telegraph长时间观察内存情况。
2. 开启GC日志。

# 术语说明

- [1]栈帧：  。
