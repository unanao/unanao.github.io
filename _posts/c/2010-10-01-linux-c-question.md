---
layout:     post
title:      "Linux c 常见问题"
subtitle:   "C语言常见问题"
author:     Sun Jianjiao
header-img: "img/bg/railway-station-1363771_1280.jpg"
catalog: true
tags:
    - c

---

# 1 C 语言编译流程

示例代码:
[源代码地址](https://github.com/unanao/unanao.github.io/tree/master/examples/2010/linux-c-compile-procedure)

```c
#include <stdio.h>

/*
 * Example for compile
 */

#define PET "little hedgehog"

int main() {
	printf("Hello lovely %s!\n", PET);

	return 0;
}

```
编译命令：

```shell
gcc hello.c -o hello
```

上面的这个编译命令包含了四个阶段的处理，即预处理(也称预编译，Preprocessing)、编译(Compilation)、汇编 (Assembly)和连接(Linking)。

## 1.1 预处理

作用： 预处理的作用主要是读入源代码，检查包含预处理指令的语句和宏定义，并对源代码进行响应的转换。预处理过程还会删除程序中的注释和多余的空白字符。

对象： 预处理指令是以“#”开头的，预处理的处理对象主要包括以下方面：

(1) #define　　宏定义  
(2) #运算符    #运算符作用是把跟在其后的参数转换成一个字符串  
(3) ##运算符　　##运算符的作用用于把参数连接到一起  
(4) 条件编译指令 #ifdef  
(5) 头文件包含指令 #include  
(6) 特殊符号 __FILE__和__LINE__ 等  

上面的hello.c文件的预处理指令是

```shell
gcc -E hello.c -o hello.i
```

## 1.2 编译-编译成汇编语言

编译命令:

```shell
gcc -S hello.i -o hello.s
```

## 1.3 汇编

作用：将上面的汇编指令编译生成目标文件

汇编命令:

```shell
gcc -c hello.s -o hello.o
```

## 1.4 链接

链接的主要目的是将程序的目标文件与所需要附加的目标文件链接起来，最终生成可执行文件。目标文件也包括了所需要的库文件（静态链接库和动态链接库）

链接命令：

```shell
gcc hello.o -o hello
```

最终生成的test文件就是最终系统可以执行的文件。

对于程序的编译，我们一般把它认为“编译”和“链接”两部分也足够了，这里的编译已经包括了预处理，编译成汇编语言和编译成目标文件三个步骤了。只要头文件完整，语法无误，编译一般都能通过。只要有完整的目标文件和功能库文件，链接也可以成功。只要编译通过了，链接也通过了，整个项目的编译就算完成了。

# 2 大小端

## 2.1 什么是大小端问题
(From《Computer Systems,A Programer's Perspective》)在几乎所有的机器上，多字节对象被存储为连续的字节序列，对象的地址为所使用字节序列中最低字节地址。

- 小端：某些机器选择在存储器中按照从最低有效字节到最高有效字节的顺序存储对象，这种最低有效字节在最前面的表示方式被称为小端法(little endian) 。这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；
- 大端：某些机器则按照从最高有效字节到最低有效字节的顺序储存，这种最高有效字节在最前面的方式被称为大端法(big endian) 。这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。

 举个例子来说名大小端:  比如一个int x, 地址为0x100, 它的值为0x1234567. 则它所占据的0x100, 0x101, 0x102, 0x103地址组织如下图:

![大小端](/img/post/c/question/big-little-endian.png)

## 2.2 为什么会有大小端模式之分

这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于 8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于 大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模 式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。

## 2.3 如何区分大小端问题

方法1：

```c
#include <stdio.h>

int main(void)
{
	int i = 1;
	unsigned char *pointer;

	pointer = (unsigned char *)&i;
	if(*pointer)
	{
		printf("litttle_endian");
	}
	else
	{
		printf("big endian\n");
	}

	return 0;
}
```

C中的数据类型都是从内存的低地址向高地址扩展，取址运算"&"都是取低地址。小端方式中（i占至少两个字节的长度）则i所分配的内存最小地址那个字节中就存着1，其他字节是0。大端的话则1在i的最高地址字节处存放，char是一个字节，所以强制将char型量p指向i，则p指向的一定是i的最低地址，那么就可以判断p中的值是不是1来确定是不是小端。

方法2：

```c
#include <stdio.h>

int main(void)
{
	union {
		short a;
		char ch;
	} u;
	u.a = 1;

	if (u.ch == 1)
	{
		printf("Littel endian\n");
	}
	else
	{
		printf("Big endian\n");
	}
}
```

利用联合体的特点，数据成员共享内存空间，union中元素的起始地址都是相同的——位于联合的开始。 用char来截取感兴趣的字节。

## 2.4 需要考虑大小端（字节顺序）的情况 

1. 所写的程序需要向不同的硬件平台迁移，说不定哪一个平台是大端还是小端，为了保证可移植性，一定提前考虑好。
2. 在不同类型的机器之间通过网络传送二进制数据时。 一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反之时，接受程序会发现，字(word)里的字节(byte)成了反序的。为了避免这类问 题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接受方机器则将网络标准转换为它的内部标准。
3. 当阅读表示整数的字节序列时。这通常发生在检查机器级程序时，e.g.：反汇编得到的一条指令：
80483bd: 01 05 64 94 04 08        add %eax, 0x8049464
4. 当编写强转的类型系统的程序时。如写入的数据为u32型，但是读取的时候却是char型的。如：0x1234, 大端读取为12时，小端独到的是34。

## 2.5 提高程序的可移植性

使用宏编译

```c
#ifdef LITTLE_ENDIAN
//小端的代码
#else
//大端的代码
#endif
```

## 2.6 大、小端之间的转换

### 2.6.1 自己编写代码将小端转换为大端

```C
#include <stdio.h>

void show_byte(char *addr, int len)
{
    int i;

	for (i = 0; i < len; i++)
    {
		printf("%.2x \t", addr[i]);
	}
	printf("\n");
}

int endian_convert(int t)
{
	int result;
	int i;

	result = 0;
	for (i = 0; i < sizeof(t); i++)
	{
		result <<= 8;
		result |= (t & 0xFF);
		t >>= 8;
	}

	return result;
}

int main(void)
{
	int i;
	int ret;

	i = 0x1234567;

	show_byte((char *)&i, sizeof(int));
	ret = endian_convert(i);
	show_byte((char *)&ret, sizeof(int));

	return 0;
}
```

### 2.6.2 Linux 库函数

本地字节序转换为网络序：

- htons -- 将short从本地字节序转换为网路字节序
- htonl -- 将long从本地字节序转换为网路字节序

网络序转化为本地字节序：

- ntons()--将short从网络字节序转换为本地字节序
- ntohl()--将long从网络字节序转换为本地字节序 

# 3 字节对齐

## 3.1 简介

### 3.1.1 什么是字节对齐

现代计算机中，内存空间按照字节划分，理论上可以从任何起始地址访问任意类型的变量。但实际中在访问特定类型变量时经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是对齐。

### 3.1.2 对齐的原因和作用

不同硬件平台对存储空间的处理上存在很大的不同。某些平台对特定类型的数据只能从特定地址开始存取，而不允许其在内存中任意存放。例如Motorola 68000 处理器不允许16位的字存放在奇地址，否则会触发异常，因此在这种架构下编程必须保证字节对齐。

但最常见的情况是，如果不按照平台要求对数据存放进行对齐，会带来存取效率上的损失。比如32位的Intel处理器通过总线访问(包括读和写)内存数据。每个总线周期从偶地址开始访问32位内存数据，内存数据以字节为单位存放。如果一个32位的数据没有存放在4字节整除的内存地址处，那么处理器就需要2个总线周期对其进行访问，显然访问效率下降很多。

因此，通过合理的内存对齐可以提高访问效率。为使CPU能够对数据进行快速访问，数据的起始地址应具有“对齐”特性。比如4字节数据的起始地址应位于4字节边界上，即起始地址能够被4整除。

此外，合理利用字节对齐还可以有效地节省存储空间。但要注意，在32位机中使用1字节或2字节对齐，反而会降低变量访问速度。因此需要考虑处理器类型。还应考虑编译器的类型。在VC/C++和GNU GCC中都是默认是4字节对齐。

### 3.1.3 对齐的分类和准则

主要基于Intel X86架构介绍结构体对齐和栈内存对齐，位域本质上为结构体类型。

对于Intel X86平台，每次分配内存应该是从4的整数倍地址开始分配，无论是对结构体变量还是简单类型的变量

## 3.2 结构体

在C语言中，结构体是种复合数据类型，其构成元素既可以是基本数据类型(如int、long、float等)的变量，也可以是一些复合数据类型(如数组、结构体、联合等)的数据单元。编译器为结构体的每个成员按照其自然边界(alignment)分配空间。各成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。

字节对齐的问题主要就是针对结构体。

```c
struct A{
    int    a;
    char   b;
    short  c;
};

struct B{
    char   b;
    int    a;
    short  c;
};
```

已知32位机器上各数据类型的长度为：char为1字节、short为2字节、int为4字节、long为4字节、float为4字节、double为8字节。那么上面两个结构体大小如何呢？

结果是：sizeof(strcut A)值为8；sizeof(struct B)的值却是12。

结构体A中包含一个4字节的int数据，一个1字节char数据和一个2字节short数据；B也一样。按理说A和B大小应该都是7字节。之所以出现上述结果，就是因为编译器要对数据成员在空间上进行对齐。

### 3.2.1 对齐准则

先来看四个重要的基本概念：

1. 数据类型自身的对齐值：char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，double型为8字节。
2. 结构体或类的自身对齐值：其成员中自身对齐值最大的那个值。
3. 指定对齐值：#pragma pack (value)时的指定对齐值value。
4. 数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}。

基于上面这些值，就可以方便地讨论具体数据结构的成员和其自身的对齐方式。

其中，有效对齐值N是最终用来决定数据存放地址方式的值。有效对齐N表示“对齐在N上”，即该数据的“存放起始地址%N=0”。而数据结构中的数据变量都是按定义的先后顺序存放。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整(即结构体成员变量占用总长度为结构体有效对齐值的整数倍)。

以此分析3.1.1节中的结构体B：

假设B从地址空间0x0000开始存放，且指定对齐值默认为4(4字节对齐)。成员变量b的自身对齐值是1，比默认指定对齐值4小，所以其有效对齐值为1，其存放地址0x0000符合0x0000%1=0。成员变量a自身对齐值为4，所以有效对齐值也为4，只能存放在起始地址为0x0004~0x0007四个连续的字节空间中，符合0x0004%4=0且紧靠第一个变量。变量c自身对齐值为2，所以有效对齐值也是2，可存放在0x0008~0x0009两个字节空间中，符合0x0008%2=0。所以从0x0000~0x0009存放的都是B内容。

再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b)所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求， 0x0000~0x0009=10字节，(10＋2)％4＝0。所以0x0000A~0x000B也为结构体B所占用。故B从0x0000到0x000B 共有12个字节，sizeof(struct B)=12。

之所以编译器在后面补充2个字节，是为了实现结构数组的存取效率。试想如果定义一个结构B的数组，那么第一个结构起始地址是0没有问题，但是第二个结构呢？按照数组的定义，数组中所有元素都紧挨着。如果我们不把结构体大小补充为4的整数倍，那么下一个结构的起始地址将是0x0000A，这显然不能满足结构的地址对齐。因此要把结构体补充成有效对齐大小的整数倍。其实对于char/short/int/float/double等已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知，所以他们的自身对齐值也就已知。

上面的概念非常便于理解，不过个人还是更喜欢下面的对齐准则。结构体字节对齐的细节和具体编译器实现相关，但一般而言满足三个准则：

1. 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
2. 结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)；
3. 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节{trailing padding}。

对于以上规则的说明如下：

- 第一条：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。
- 第二条：为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员大小的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。
- 第三条：结构体总大小是包括填充字节，最后一个成员满足上面两条以外，还必须满足第三条，否则就必须在最后填充几个字节以达到本条要求。

```c
 struct A {
 4     char  a;
 5     short b;
 6     char  c;
 7     int   d;
 8     char  e[3];
 9 }
```

下面来具体分析：

- 首先char a占用1个字节，没问题。
- short b本身占用2个字节，根据上面准则2，需要在b和a之间填充1个字节。
- char c占用1个字节，没问题。
- int d本身占用4个字节，根据准则2，需要在d和c之间填充3个字节。
- char e[3]；本身占用3个字节，根据原则3，需要在其后补充1个字节。

因此，sizeof(A) = 1 + 1 + 2 + 1 + 3 + 4 + 3 + 1 = 16字节。

# 4 位域

些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1两种状态，用一位二进位即可。为了节省存储空间和处理简便，C语言提供了一种数据结构，称为“位域”或“位段”。

位域是一种特殊的结构成员或联合成员(即只能用在结构或联合中)，用于指定该成员在内存存储时所占用的位数，从而在机器内更紧凑地表示数据。每个位域有一个域名，允许在程序中按域名操作对应的位。这样就可用一个字节的二进制位域来表示几个不同的对象。

```c
struct
{
	unsigned int widthValidated : 1;
	unsigned int heightValidated : 1;
} status;
```

现在，上面的结构中，status 变量将占用4个字节的内存空间，但是只有 2 位被用来存储值。如果您用了32 个变量，每一个变量宽度为1位，那么 status 结构将使用4个字节，但只要您再多用一个变量，如果使用了33个变量，那么它将分配内存的下一段来存储第33个变量，这个时候就开始使用8个字节。

# 5 防止重复包含

```c
//方式一：
#ifndef _SOMEFILE_H_
#define _SOMEFILE_H_
//.......... // 一些声明语句
#endif

//方式二：
#pragma once
//... ... // 一些声明语句
```

pragma once由编译器提供保证： 同一个文件不会被编译多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。 带来的好处是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题。对应的缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名碰撞引发的“找不到声明”的问题，重复包含更容易被发现并修正。

# 6 内存布局

![c语言内存布局](/img/post/c/question/c-memory.png)

- 正文段（Text Segment），保存CPU将要执行的机器指令。文本段是可共享的，所以某个程序多次执行时，对应的文本段只需要在内存中存有一份拷贝。文本段是只读的（read-only），防止程序的指令被修改。
- 初始化数据段（initialized data segment），保存程序中被初始化的全局变量（定义在任何函数之外）。例如：int maxcount = 99; 全局变量变量maxcount被保存在初始化数据段。
- 未初始化数据段（uninitialized data segment），也被称为BSS（block started by symbol），这个段中的数据在程序执行之前被内核初始化为0或者null。;例如定义一个全局变量（定义在任何函数之外），long sum[1000];  该变量保存在未初始化数据段中。
- 栈（Stack）：存储临时变量，函数相关信息。当一个函数被调用时，返回地址、调用者相关信息（如寄存器信息）会被保存在栈中。该被调用的函数会在栈上分配一部分空间保存它的临时变量。函数的递归调用也是应用这个原理。每一次函数调用自己，都会保存当前函数的信息，然后再栈上开辟一个新的空间用于保存该次函数的信息，和以前的函数并没有影响。
- 堆（Heap）：动态内存分配位置。堆的位置位于未初始化数据段和栈的中间。
