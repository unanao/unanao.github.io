---
layout:     post
title:      "Mysql基础"
subtitle:   "Mysql的基础知识和一些实现机制"
author:     Sun Jianjiao
header-img: "/img/bg/railway-station-1363771_1280.jpg"
catalog: true
tags:
    - 数据库

---

# 1 事务

事务内的语句，要么全部执行成功，要么全部执行失败回滚。

银行应用事务必要性的的一个经典例子。假设银行的数据库有2张表：支票表（checking）表和储蓄表（savings）。现在要从用户jane的支票账户转义200元到她的储蓄帐户，那么需要2个步骤：

- 加查支票账户余额是否高于200元
- 从支票账户中减去200元
- 储蓄账户余额中增加200元

以上3个操作必须打包在一个事务中，任何一个步骤是白，必须同时会滚所有的操作。

事务满足ACID。

- 原子性(Atomictiy): 整个事务中的所有操作要么全部提交成功，要么全部失败回滚。不可能执行其中的一部分操作
- 一致性(consitency): 数据库总是从一个一致性的状态转换到另一个一致性的状态。如前面的例子，执行完第2步和第3步之间的时候系统崩溃了，支票余额不会被扣除200元。
- 隔离性(isolation): 一个事物所做的修改在最终提交以前，对其他事务“通常来说”是不可见的。执行完第2步和第3步之间的时候， 另一个账户汇款程序看到的支票余额不会减去200元。
- 持久性(durability): 一旦事务提交，其所做的修改就会永久保存在数据库中。

## 1.1 隔离级别

SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。

- READ UNCOMMITED(未提交读)： 事务中的修改，即使没有提交，对其他事物也都是可见的。事务可以读取未提交的数据，会导致脏读，而且性能没有好太多，所以实际应用中一般很少使用。
- READ COMMITED(提交读)：一个事物提交前，只能“看见”已经提交事务的的修改。但是A事务读取数据后，B事务更新了数据，A事务再次读到的数据和第一次可能不一样，所以也叫“不可重复读”。
- REPEATABLE READ(可重复读)：解决了脏读和事务中多次读取同一个记录的结果是一致的。但是读取某个范围内的数据，另一个事务插入了新的记录，之前事务再次读取会产生“幻读”。InnoDB通过MVCC（多本版并发控制）解决了幻读问题。可重复读是Mysql的默认事务隔离级别。
- SERIALIZABLE（可串行化）：最高的隔离级别, 它通过强制事务串行执行，避免了前面的幻读问题。这样就会在每一行数据上加锁，导致性能低下。实际中也很少用到这个隔离级别。

## 1.2 多版本并发控制(MVCC)

可以认为MVCC是行锁的一个变种，但是它在很多场景下避免了加锁操作，因此开销较低。实现了非阻塞的读操作，锁定必要行的写操作。

MVCC的实现是通过保存数据在某个时间点的快照实现的，也就是说不管多长时间，每个事务看到的数据是一致的。InnoDB的MVCC是通过在每行记录后面保存2个隐藏的列来实现的。这两个列一个保存了行创建时间，一个保存了过期时间。不是具体的时间值而是系统版本号，没开始一个新的事物，系统版本号都会自动递增。事务开始的系统版本号会作为事务的版本号用来和每行记录的版本号进行比较。
