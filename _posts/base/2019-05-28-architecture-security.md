---
layout:     post
title:      "Web 安全"  
subtitle:   "基本攻击手段和预防措施"
author:     Sun Jianjiao
header-img: "img/bg/default-bg.jpg"
catalog: true
tags:
    - architecture

---

安全永远是相对的，没有最安全，只有更安全。

# 1 常见的Web 攻击手段

常见的Web攻击手段，主要包括XSS攻击，CSRF攻击，SQL注入攻击，DDos攻击等。XSS，CSRF和SQL注入相对来说比较容易防范，对症下药即可，对于起来说需要从开发流程上予以保障，以免人为疏忽造成损失。对于DDOS攻击来说，攻击手段多样，产生的影响危害巨大。

## 1.1 XSS攻击

XSS攻击的全称是跨站脚本攻击(Cross Site Scripting), 为了不和WEB中的CSS混淆，缩写为XSS。跨站脚本攻击指的是攻击者在网页中嵌入而已脚本程序，**当用户打开网页时，脚本程序便开始在客户端的浏览器上执行**，以盗取客户端cookie, 用户名密码，下载病毒木马程序，设置是获取客户端的admin权限等。

### 1.1.1  XSS 原理

一个场景，用户在表单上输入一段数据后，提交给服务端进行持久化。其他人访问的页面从后端获取了这段数据。如：

```html
<body>
    <script> alert("恶意程序") </script>
</body>
```

如果一个而已用户在知名的博客网站转载了一篇非常火的文章，文章中嵌入恶意的脚本代码，其他人访问这篇文章时，嵌入在文章中的脚本便会执行，达到了恶意攻击的目的。

连接也不要随便点开，如果这个链接是一个包含了恶意代码的URL，并且采用URLEnCode使得这个链接看起来很正常，如果以邮件群发的形式发送，一旦用户点击，脚本在客户端就会执行，造成危害。

### 1.1.2 XSS 防范

XSS之所会发生，是因为用户输入的数据变成了代码。因此我们需要对用户输入的数据进行HTML转义如，如尖括号，单引号，双引号之类的特殊字符进行转义。

| HTML 字符| HTML 转义后的字符|
| :-------| :----------------|
| <       | &lt              |
| >       | &gt              |
| '       | &amp             |
| "       | &quot            |

如今开源的开发框架本身默认就提供HTML转义功能，如jstl, Struts，Spring等。

## 1.2 CSRF 攻击

CRSF的全称是跨站请求伪造(Cross Site Request Forgery), 是一种对网站的恶意利用。XSS利用的是站内的信任，用户点击和浏览触发脚本执行。CSRF是盗用了你的身份，伪装成是你在向第三方网站发送而已请求。CSRF能做的事情包括利用你的身份发送邮件，发短信，进行交易转账等，甚至盗取你的账号。

### 1.2.1 CSRF攻击原理

![CSRF](/img/post/architecture/security/CSRF.jpg)

1. 用户C浏览受信任站点A, 登录信息验证通过后。站点A会在返回给浏览器的信息中带上已登录的cookie，cookie会在浏览器保存一定时间（取决于服务端的设置）
2. 用户C在没有登出A的情况下，访问了恶意站点B，这时恶意站点B向站点A发起请求，这个请求会带上浏览器所保存的站点A的cookie
3. 站点A以为此请求是用户C发出的，站点B成功的伪造了用户C访问A的目的。

很多情况下所谓的**恶意站点**，很有可能就是一个存在其他漏洞(如XSS)的受信任，且被很多人访问的站点，这样，普通用户就可能在不知不觉中变成了受害者。

### 1.2.2 攻击举例

1. 用户登录了某网上银行的站点A。
2. 某大型论坛的站点B。一个恶意用户写了一个恶意的链接。链接是站点A的转账地址。
3. 没有登出站点A，访问了站点B，点击了这个转账地址。

不幸的事情发生了，用户的钱被转走了。

以上只是举例，银行的交易都有USB 可以，验证码，登录密码，支付密码等一些列保障，安全系数高的多。

### 1.2.3 CSRF的防御

#### 1.2.3.1 将cookies设置为HttpOnly

CRSF攻击很大程度上利用了浏览器的cookies， 为了防止站内的XSS漏洞盗取cookie， 需要在cookie中设置"HttpOnly"属性，这样就无法通过程序（如Javascript、applet等）读取到cookie信息。

#### 1.2.3.2 增加token

CSRF攻击之所以能够成功，因为攻击者可以伪造用户的请求，所有的验证信息都在cookie中。所以只要在请求中放入攻击者不能伪造的信息，并且该信息不存在与cookie中。所以开发人员可以在HTTP请求中以参数的形式随机产生一个token, 并且咋服务端进行校验。

#### 1.2.3.3 通过Referer识别

HTTP头中有一个字段叫Referer, 它记录了HTTP请求的源地址。通常情况下HTTP请求的的地址来自对应的前端页面。如果是攻击者就是其他的地址。

## 1.3 SQL 注入

把Sql命令伪装成HTTP请求的参数，传递到服务端，欺骗服务器执行恶意的SQL命令，达到入侵的目的。

### 1.3.1 SQL注入的攻击原理

如一个登录的SQL, 用户需要传入用户名（name）和密码(password), 采用SQL拼装的方式：

```SQL
"select * from user where name = " + name + "and password = " +  password  
```

恶意用户可以在输入password的时候做手脚:

```SQL
// 不用密码就可以登录
"select * from user where name = " + name + "and password = " +  password = '' or '1' = '1'

//或者删除user表

"select * from user where name = " + name + "and password = " +  password = "'' "; drop table user"
```

### 1.3.2 SQL注入的防范

#### 1.3.2.1 预编译语句
PreparedStatement是java.sql的一个接口，继承自Statement接口。

- 通过Statement对象执行SQL语句，需要将SQL语句发送给DBMS，由DBMS先进行编译后在执行。
- PreparedStatement与Statement不同，在创建PreparedStatement对象时就置顶了SQL语句，该语句立即发送给DMBS编译，DBMS直接玉兴编译后的SQL语句。

引发SQL注入的根本原因是恶意用户将SQL指令指令**伪装成参数**传到后端数据库执行。预编译语句使用占位符的方式代替需要动态传入的参数，这样攻击者无法改变SQL语句的结构，SQL语句的转义不会发生改变。

#### 1.3.2.2 ORM框架

对于Mybatis和hibernate都支持对应的关键字或者特殊字符进行转义。如Mybatis: 

```Java
 @Insert("INSERT INTO active_code(id, email, active_code, expire_time) " "VALUES(#{id}, #{email}, #{activeCode}, #{expireTime})")
```

通过#号传入的参数，mybatis会对变量进行转义，防止SQL注入。

## 1.4 文件上传攻击

1. 校验文件类型，通过白名单的方式检查文件是否可以上传。不是通过简单的后缀，而是通过魔数。
2. 限制文件大小。
3. 文件重命名
4. 图片通过imagemagic对图片你进行压缩。

## 1.5 DDos 攻击

分布式拒绝服务攻击(Distribute Denial of service)，是目前最强大，最难以防御的攻击方式之一。Dos就是利用合理的客户端请求来占用过多的服务器资源，从而使合法用户无法得到服务器的响应。DDos就是将数量庞大的计算机设备联合起来作为攻击平台，对一个或者多个目标发动攻击。

可以依赖协议特征和具体的软件漏洞进行攻击，如Hash碰撞攻击。

架构安全依靠防火墙，防火墙的基本功能是隔离网络，通过网络划分成不同的区域，制定出不同区域之间的访问控制策略来控制不同信任程度区域间出阿松的数据流。

防火墙虽然功能强大，但是性能一般。DDos攻击轻则几GB，重则几十GB。如果使用防火墙，成本就很高，而且需要维护成本，关键是平时还没用。防火墙能够保证内部系统不受攻击，但是如果带宽耗尽，对于用户来说，业务已经受影响了。

目前灭有太好的手段解决和实现，更多的可以依靠运营商或者云服务商强大的带宽和流量清洗能力，较少自己实现。

# 2. 常用的安全算法

## 2.1 数字摘要

它由一个单项的**Hash函数**对消息进行计算而产生，将需要计算的内容“摘要”成**固定长度的串**，这个串也成为数字指纹。

- 生成的摘要长度是固定的
- 输入不同，计算出来的摘要也不相同（相对的，好的算法碰撞很少，但是也存在碰撞的可能）。 输入相同，得到的摘要一定相同。
- 只包含部分摘要信息，不能从摘要中还原信息。

加密算法, 主要包括**MD5和SHA**，SHA更安全，但是更慢。可以通过*彩虹表破解Hash算法**。
编码算法：十六进制编码和Base64编码

## 2.2 对称加密算法

加密算中，使用的密钥只有一个，发送和接收双方都是用这个密钥对数据进行加密和解密，这就需要**加密和解密方事先都必须知道机密的密钥**。

主要包括DES，3DES(DES向AES的过渡)和AES算法。AES更安全，已经成为对称算法中最流行的算法之一。

## 2.3 非对称加密算法

非对称加密算法又称为公开密钥的加密算法，他需要2个密钥:

- 公钥
- 私钥

使用公钥进行加密，只有对应的私钥才能解密；使用私钥进行加密，只有公钥才能揭密接。

非对称加密算法的信息交换过程：

- 甲方先生成一对密钥，将其中的一个作为公钥，向其他人公开。
- 得到公钥的乙方，使用得到的密钥对信息进行加密，然后再发送给甲方。
- 甲方使用自己保存的私钥对机密信息进行解密。

对称算法只有一中密码，并且是非公开的，一旦泄露，加密信息就不安全。非对称密钥有2个密钥，其中一个是公开的，就不需要对公钥进行加密了。

非对称加密非常复杂，加密速度没有对称加密快。所以可以采用对称算法加密加长的文件，非对称密钥给文件密钥加密，解决对称密钥分发的问题。

主要算法: RSA

## 2.4 数字签名

前面认证是非对称加密和数字摘要技术的综合应用。

- 通信内容的摘要信息使用发送者的密钥进行加密
- 接收者通过发送者的公钥解密加密的摘要信息
- 接收者对接收到的内容采用相同的方法生成摘要，与解密的摘要进行对比，判断收到的内容是否被篡改。

常见的数字签名算法包括：MD5withRSA和SHA1withRSA

## 2.5 数字证书

数字证书(Digital Certificate)也成为电子证书，类似于日常生活中的身份证，也是另外一种形式的身份的认证，用于标识网络总的用户身份。

- 颁发机构用私钥对证书进行签名，证书自身带有公钥信息，可以完成相应的加密和解密操作
- 拥有自身的数字签名，可以鉴定证书的颁发机构和证书内容的完整性
- 校验方使用公钥来解密签名，与摘要算法生成的摘要进行比较
- 还会包括认证信息，过期时间等。

大多数证书采用标注的格式, 及X.509。

### 2.5.1 证书签发

网络用户的数字证书需要有数字认证机构(Certificate Authority, CA)进行颁发。证书签发的过程实际就是对数字证书的内容，包括证书所代表对象的公钥进行数字签名

### 2.5.2 证书校验

实际上就是校验数字证书的数字签名。 大多数操作系统夺回预装一些较为权威的证书认证机构的证书，如VeriSign，GeoTrust等，如果证书是非权威机构的证书，用户需要自行下载安装证书认证机构的根证书。

### 2.5.3 证书管理

任何个人都可以申请数字证书，并使用数字证书对网络通信保驾护航。要获得数字证书，需要需要使用数字证书管理工具（如keytool, openSSL等），然后构建CSR（Certificate Signing Request, 数字证书签发申请），提交给数字证书认证机构进行签名，最终形成数字证书。

# 3 HTTPS协议

HTTPS的全称是Hyptextet transfter protocol over Secure Socket Layer, 即基于SSL的HTTP协议。

## 3.1 SSL/TSL

SSL的继任者是TSL(传输层安全协议)，基于SSL的通用化协议，同样位于应用程和传输层之间，正逐步接替SSL成为新一代网络安全协议。

