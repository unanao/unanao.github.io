---
layout:     post
title:      "数据库主键设计"
subtitle:   ""
author:     Sun Jianjiao
header-img: "img/bg/railway-station-1363771_1280.jpg"
catalog: true
tags:
    - 数据库
    - Database
    - 主键

---

# 主键

> 数据库设计主要是对实体和关系的设计，实体就是表，关系就是外键。对于一个表，由两部分组成：主键和属性。主键是表中每一行数据的唯一标识。主键是定位到一条记录并且确保不会重复存储的逻辑机制，更方便的检索和管理数据。由于主键常常用于检索数据，被外键引用来建立表与表之间的关系，所以主键设计的好坏将会严重影响数据操作的性能。

主键可以分为**业务主键**和**代理主键**：

业务主键可以是**一个字段单独做主键**， 也可以是多个字段组合在一起做组成**联合主键**。使用表中的业务字段作为主键，这种表并不多， 因为要保证该字段长久的具有行记录唯一的特点。一旦修改非常麻烦(比如身份证，15位变18位)，如果作为其他表的外键就需要同步修改。**联合主键**有不只1列，如果会被其他表作为外键，就需要存多列。业务主键建议尽量不要使用，本文就不考虑业务主键了。

## 代理主键
新增一列与业务无关的唯一性的字段做主键，也称之为“伪主键”。引入一个对于表的域模型无意义的新列来存储一个伪值。 这一列被用作这张表的主键，从而通过它来确定表中的一条记录，即其他的列允许出现适当的重复项。

代理主键的好处：

- 消除主键（业务字段）修改引起的一致性问题 
因为业务列都有修改的可能性（比如员工号，产品编号等等），如果有其他表引用该字段作为外键，要引起级联修改。

- 消除联合主键由多个字段组成引起的冗余存储
如果业务主键由多个列组成（比如上班打卡记录，由员工号+日期组成），如果有其他表引用该表的主键做外键，需要存储多个字段，造成存储空间的扩大。

- 业务主键无法实现的情况
比如有多个字段作为主键，在应用中只有这些字段全部输入后才能保存，现实中有些功能是“保存草稿”状态的，也就是说必填字段可以在没有填写的情况下实现保存，如果不采用逻辑主键的话，此功能就无法实现。

- 传递更少的参数 
应用程序中不方便，比如像查询一个对象的明细信息，如果采用关联主键，可能需要传递多个参数才能确定一条数据（更方便地实现业务功能）

## 常用代理主键的生成策略

### 自增主键

数据库提供的自增数值型字段作为自增主键，它的优点是：

- 数据库自动编号，速度快，而且是增量增长，按顺序存放，对于检索非常有利；
- 数字型，占用空间小，易排序，在程序中传递也方便；
- 如果通过非系统增加记录时，可以不用指定该字段，不用担心主键重复问题。

其实它的缺点也就是来自其优点，缺点如下:  

- 因为自动增长，在手动要插入指定ID的记录时会显得麻烦，尤其是当系统与其它系统集成时，需要数据导入时，很难保证原系统的ID不发生主键冲突（前提是老系统也是数字型的）。特别是在新系统上线时，新旧系统并行存在，并且是异库异构的数据库的情况下，需要双向同步时，自增主键将是你的噩梦；
- 很难处理分布式存储的数据表

MySQL（auto_increment）、SQL Server（IDENTITY）、Informix、Oracle（首先创建自增序列，接着为自增主键的表创建插入时的触发器，给自增主键ID赋值）等数据库都支持这种自增主键，这种主键在各种系统中应用广泛。
但是如果考虑到有新旧系统并存等问题，为了避免不必要的麻烦，使用自增主键要三思。


### 只考虑唯一性的主键

UUID主键或者根据业务自己生成（如基于IP,线程ID，时间戳，本机计数器等因素）唯一的ID

主要优点是：

- 生成管理方便——完全由算法自动生成，不需要一个权威机构来管理，在空间上和时间上具有唯一性，保证同一时间不同地方产生的数字不同。
- 系统集成方便———世界上的任何两台计算机都不会生成重复的UUID值，　所以几个系统的UUID值导到一起时，也不会发生重复。
- 数据库移植方便——UUID列可以作为字符型列转换到其它数据库中，同时将应用程序中产生的UUID值存入数据库，不会对原有数据带来影响。
- UUID的长度固定，并且相对而言较短小，非常适合于排序、标识和存储。

缺点是：

- UUID值较长，不容易记忆和输入，而且这个值是随机、无顺序的。
- UID的值有16个字节，与其它诸如4字节的整数相比要相对大一些。这意味着如果在数据库中使用键，可能会带来两方面的消极影响：存储空间增大、索引时间会慢一些。

### 数字型主键
如BigInt类型。

1. 单实例的情况
ID生成器和服务在同一个服务，服务启动的时候，从数据库取最大的ID，并且记录在内存中，每插入一条数据对数据进行更新。

2. 多实例的情况
单独启动一个服务，按照未分表前的表名统一生成ID。 每次生成ID后，更新次ID序列的最大值。为了减少远程获取ID的开销，通过批量获取一段ID，然后缓存在本地，这样就不需要每次另一个服务获取了。如果系统挂了，那么这段ID就浪费了，一次获取的数量适量，宕机的情况有很少，这个问题基本可以忽略不计。

# 数据库优化
在不升级硬件的情况下，加压的主要思路：

- 应用优化，看看是否有不要的压力给了数据库
- 引入缓存, 降低对数据库的压力
- 数据库的数据和访问分到多台数据库上

## 数据拆分

### 垂直拆分
垂直拆分就是把一个数据库中不同业务单元的数据分到不同的数据库里面

- 单机的ACID保证被打破了。数据分散到多机后，原来在单机通过事物进行的处理逻辑会受到很大的影响。要么放弃原来的单机事务，修改实现；要么引入分布式事务。
- 一些Join操作变得很困难
- 靠外键去进行约束的场景会收到影响

### 水平拆分
水平拆分是根据一定的规则把统一业务单元的数据拆分到多个数据库中。

- 同样单机的ACID保证被打破了
- 同样一些Join操作变得很困难
- 同样靠外键去进行约束的场景会收到影响
- 依赖单裤的自增序列生成唯一ID将会受影响。
- 针对单个逻辑意义上的表单的查询要跨库了

从工程上来说，如果能够避免分布式事务的引入，那么还是避免为好；如果一定要引入分布式事务，那么，可以考虑最终一致的方法，而不要追求强一致。而且从实现上来说，最好通过补偿的机制不断重试，让之前因为异常而没有进行到底的操作继续进行，而不是回滚。

## 跨库Join

最好能够设计好分库分表规则，分库分表后需要的数据还在同一个数据库中，同样还是单库单表问题。
分库后，如果原来需要join的数据还在一个库里面，那就可以直接进行join。如按照用户ID进行分布，那么用户信息的join数据同样分布到相同的库中了，还是可以join的。

如果需要join的数据分布在不同的库中，这会比较麻烦:

- 应用层把原来join大的操作分成多次数据库操作。根据ID一个一个查询出来。
- 数据冗余，对一些常用信息进行冗余，这样就可以直接进行join操作。Mycat就有Global操作，只要写入到Global标记的表中，数据会同步到每一个表中，这就解决了常用信息的join问题。

## 改写SQL

- 表名需要有后缀区分，这样可以减少误操作，同时进行数据迁移的时候也比较方便。
- 索引名也需要修改，需要从逻辑上的名字变为对应数据库中的名字
- 平均值计算不能从多个数据源取平均值，再计算平均值，必须获取所有数据再计算平均值。

## 读写分离

- Mydql的Replication可以解决复制的问题，并且延时也相对较小。业务根据自身的业务特点从备库读取对数据不太敏感的数据。
- 通过消息系统就数据库的更新送出消息通知，数据同步服务器获得消息通知后会进行数据的复制工作，分库规则配置服务负责通知分库规则。这个方式不是很优雅，比较优雅的方式时通过数据库的日志进行数据的复制。

## 数据迁移

1. 数据迁移是记录增量日志
2. 迁移结束后，被迁移的数据写暂停，处理增量变化
3. 增量日志处理完毕，切换规则，放开所有的写。
